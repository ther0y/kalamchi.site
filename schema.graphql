# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: query_root
    mutation: mutation_root
    subscription: subscription_root
}

"whether this query should be cached (Hasura Cloud only)"
directive @cached(
    "refresh the cache entry"
    refresh: Boolean! = false,
    "measured in seconds"
    ttl: Int! = 60
) on QUERY

type Game {
    date: String!
    guess_count: Int!
    id: uuid!
    round: Int!
    word: String!
}

type LoginOutput {
    accessToken: String!
    id: String!
    refreshToken: String!
}

"columns and relationships of \"games\""
type games {
    date: timestamp!
    id: uuid!
    round: Int!
}

"mutation root"
type mutation_root {
    login(password: String!, username: String!): LoginOutput
}

type query_root {
    gameById(id: String!): Game
    "fetch data from the table: \"games\""
    games(
        "distinct select on columns"
        distinct_on: [games_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [games_order_by!],
        "filter the rows returned"
        where: games_bool_exp
    ): [games!]!
    "fetch data from the table: \"games\" using primary key columns"
    games_by_pk(id: uuid!): games
}

type subscription_root {
    "fetch data from the table: \"games\""
    games(
        "distinct select on columns"
        distinct_on: [games_select_column!],
        "limit the number of rows returned"
        limit: Int,
        "skip the first n rows. Use only with order_by"
        offset: Int,
        "sort the rows by one or more columns"
        order_by: [games_order_by!],
        "filter the rows returned"
        where: games_bool_exp
    ): [games!]!
    "fetch data from the table: \"games\" using primary key columns"
    games_by_pk(id: uuid!): games
}

"select columns of table \"games\""
enum games_select_column {
    "column name"
    date
    "column name"
    id
    "column name"
    round
}

"column ordering options"
enum order_by {
    "in ascending order, nulls last"
    asc
    "in ascending order, nulls first"
    asc_nulls_first
    "in ascending order, nulls last"
    asc_nulls_last
    "in descending order, nulls first"
    desc
    "in descending order, nulls first"
    desc_nulls_first
    "in descending order, nulls last"
    desc_nulls_last
}

scalar timestamp

scalar uuid

"Boolean expression to compare columns of type \"Int\". All fields are combined with logical 'AND'."
input Int_comparison_exp {
    _eq: Int
    _gt: Int
    _gte: Int
    _in: [Int!]
    _is_null: Boolean
    _lt: Int
    _lte: Int
    _neq: Int
    _nin: [Int!]
}

"Boolean expression to filter rows from the table \"games\". All fields are combined with a logical 'AND'."
input games_bool_exp {
    _and: [games_bool_exp!]
    _not: games_bool_exp
    _or: [games_bool_exp!]
    date: timestamp_comparison_exp
    id: uuid_comparison_exp
    round: Int_comparison_exp
}

"Ordering options when selecting data from \"games\"."
input games_order_by {
    date: order_by
    id: order_by
    round: order_by
}

"Boolean expression to compare columns of type \"timestamp\". All fields are combined with logical 'AND'."
input timestamp_comparison_exp {
    _eq: timestamp
    _gt: timestamp
    _gte: timestamp
    _in: [timestamp!]
    _is_null: Boolean
    _lt: timestamp
    _lte: timestamp
    _neq: timestamp
    _nin: [timestamp!]
}

"Boolean expression to compare columns of type \"uuid\". All fields are combined with logical 'AND'."
input uuid_comparison_exp {
    _eq: uuid
    _gt: uuid
    _gte: uuid
    _in: [uuid!]
    _is_null: Boolean
    _lt: uuid
    _lte: uuid
    _neq: uuid
    _nin: [uuid!]
}
